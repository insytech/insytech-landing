---
import Container from "../shared/Container.astro";
import Paragraph from "../shared/Paragraph.astro";

const sectors = [
    {
        id: "automotive",
        code: "AUTO-MES",
        title: "Sector Automotriz",
        description: "Implementación de sistemas MES y SCADA con integración total de PLCs y sensores mediante protocolos MODBUS para el monitoreo en tiempo real.",
        visualId: "mes-hub"
    },
    {
        id: "electronics",
        code: "ELEC-MOD",
        title: "Manufactura Electrónica",
        description: "Enfoque en sistemas de ensamble convencional y estaciones de prueba funcional con trazabilidad integrada para componentes críticos.",
        visualId: "pcb-trace"
    },
    {
        id: "logistics",
        code: "LOGI-SCALE",
        title: "Logística y Empaque",
        description: "Sistemas de reempaquetado automatizados con básculas dinámicas integradas para el control de peso y auditoría de envíos.",
        visualId: "scale-flow"
    },
    {
        id: "metal",
        code: "META-INST",
        title: "Metal-mecánica",
        description: "Soporte en instalaciones electromecánicas de precisión y montaje técnico especializado de herramentales y periféricos industriales.",
        visualId: "service-stack"
    }
];
---

<section id="features" class="relative pt-12 pb-20 bg-white dark:bg-[#020308]">
    <!-- Background exactly like Process.astro but with different pattern -->
    <div class="absolute -left-10 top-0 h-full w-full flex justify-start opacity-30 dark:opacity-40 pointer-events-none">
        <div class="feature-mancha w-64 h-64 overflow-auto flex rounded-xl relative blur-3xl">
          <span class="absolute w-40 h-40 -top-1 -right-1 bg-[#00B5E2] rounded-md rotate-45"></span>
          <span class="absolute w-40 h-40 -bottom-1 -right-1 bg-[#005EB8] rounded-md rotate-45"></span>
          <span class="absolute w-40 h-40 -bottom-1 -left-1 bg-[#001489] rounded-md rotate-45"></span>
        </div>
    </div>

    <div class="absolute -right-10 -bottom-10 h-full w-full flex justify-end items-end opacity-30 dark:opacity-40 pointer-events-none">
        <div class="feature-mancha w-48 h-48 overflow-auto flex rounded-xl relative blur-3xl">
          <span class="absolute w-32 h-32 -top-1 -right-1 bg-[#00B5E2] rounded-md rotate-45"></span>
          <span class="absolute w-32 h-32 -bottom-1 -right-1 bg-[#005EB8] rounded-md rotate-45"></span>
          <span class="absolute w-32 h-32 -bottom-1 -left-1 bg-[#001489] rounded-md rotate-45"></span>
        </div>
    </div>

    <Container className="relative z-10 max-w-[1600px]">
        <!-- Header - Exact match to Services.astro -->
        <div class="max-w-6xl mb-24 md:mb-32 features-header opacity-0">
            <h2 class="text-5xl md:text-7xl font-black text-[#002B49] dark:text-white leading-[1.05] tracking-tight">
                Impacto <span class="text-transparent bg-clip-text bg-gradient-to-r from-[#005EB8] to-[#00B5E2]">Sistémico</span>
                <br /> por Sector Operativo
            </h2>
            <div class="mt-8">
                <Paragraph className="text-xl font-medium leading-relaxed max-w-2xl">
                    Nuestra infraestructura técnica redefine los límites de la manufactura moderna a través de la síntesis de automatización e inteligencia propia.
                </Paragraph>
            </div>
        </div>

        <!-- 4-Column Asymmetric Grid -->
        <div class="grid grid-cols-1 lg:grid-cols-4 gap-px bg-gray-200 dark:bg-white/10 border-x border-gray-200 dark:border-white/10">
            {sectors.map((sector) => (
                <div 
                    class="group relative flex flex-col bg-white dark:bg-[#020617] p-7 lg:p-14 min-h-[600px] lg:min-h-[650px] transition-colors duration-700 sector-card opacity-0 overflow-hidden"
                >
                    <!-- Background Grainy Noise -->
                    <div class="absolute inset-0 opacity-[0.02] dark:opacity-[0.05] pointer-events-none mix-blend-overlay bg-[url('https://grainy-gradients.vercel.app/noise.svg')]"></div>

                    <div class="relative z-10 h-full flex flex-col">
                        <div class="flex justify-between items-start mb-16">
                            <span class="text-[11px] font-mono font-black text-[#005EB8] dark:text-[#00B5E2] tracking-widest">{sector.code}</span>
                            <div class="h-10 w-[1px] bg-gray-200 dark:bg-white/10"></div>
                        </div>

                        <h3 class="text-3xl lg:text-4xl font-black text-[#002B49] dark:text-white leading-tight tracking-tight uppercase mb-8 sector-title opacity-0">
                            {sector.title}
                        </h3>
                        
                        <!-- Three.js Visual Area (Larger) -->
                        <div class="flex-grow flex items-center justify-center -mx-4">
                            <div class="w-full aspect-square relative feature-visual" data-visual={sector.visualId}>
                                <canvas class="three-canvas w-full h-full"></canvas>
                                <!-- Technical HUD element -->
                                <div class="absolute inset-0 border border-[#00B5E2]/10 rounded-full scale-110 opacity-0 group-hover:opacity-100 transition-all duration-1000"></div>
                                <div class="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 w-4 h-4 border border-[#00B5E2] rounded-full opacity-20 animate-ping"></div>
                            </div>
                        </div>

                        <div class="mt-auto pt-16 space-y-6">
                            <div class="h-[1px] w-12 bg-[#00B5E2]"></div>
                            <p class="text-gray-500 dark:text-gray-400 font-medium leading-relaxed text-lg sector-desc opacity-0">
                                {sector.description}
                            </p>
                            <div class="flex items-center gap-4 text-[9px] font-black uppercase tracking-[0.5em] text-gray-400 opacity-0 group-hover:opacity-100 transition-all duration-700">
                                <span>Status</span>
                                <span class="text-emerald-500">Optimized</span>
                            </div>
                        </div>
                    </div>

                    <!-- Scanline Effect -->
                    <div class="absolute inset-0 pointer-events-none bg-gradient-to-b from-transparent via-[#00B5E2]/5 to-transparent h-20 -translate-y-full group-hover:animate-scan"></div>
                </div>
            ))}
        </div>

        <!-- Global Summary Section -->
        <div class="mt-32 grid grid-cols-1 lg:grid-cols-12 gap-12 items-center features-footer opacity-0 border-t border-gray-100 dark:border-white/5 pt-16">
            <div class="lg:col-span-4 space-y-4">
                <span class="text-[10px] font-mono font-black text-[#00B5E2] uppercase tracking-[0.4em]">Integrated Performance</span>
                <h4 class="text-3xl font-black text-[#002B49] dark:text-white leading-none tracking-tight uppercase">Métricas de <br/> <span class="text-transparent bg-clip-text bg-gradient-to-r from-[#005EB8] to-[#00B5E2]">Impacto Real</span></h4>
            </div>
            <div class="lg:col-span-8 grid grid-cols-2 lg:grid-cols-4 gap-8 sm:gap-12">
                <div class="space-y-3">
                    <div class="flex items-baseline gap-1">
                        <p class="text-5xl font-black text-[#002B49] dark:text-white tracking-tighter leading-none">99.9</p>
                        <span class="text-xl font-bold text-[#00B5E2]">%</span>
                    </div>
                    <p class="text-[10px] font-black text-gray-400 uppercase tracking-widest leading-tight">Uptime de <br/> Infraestructura</p>
                </div>
                <div class="space-y-3">
                    <p class="text-5xl font-black text-[#00B5E2] tracking-tighter leading-none">24/7</p>
                    <p class="text-[10px] font-black text-gray-400 uppercase tracking-widest leading-tight">Monitoreo <br/> Proactivo</p>
                </div>
                <div class="space-y-3">
                    <div class="flex items-baseline gap-1">
                        <span class="text-xl font-bold text-[#00B5E2]">&lt;</span>
                        <p class="text-5xl font-black text-[#002B49] dark:text-white tracking-tighter leading-none">1</p>
                        <span class="text-xl font-bold text-[#00B5E2]">ms</span>
                    </div>
                    <p class="text-[10px] font-black text-gray-400 uppercase tracking-widest leading-tight">Latencia de <br/> Respuesta</p>
                </div>
                <div class="space-y-3">
                    <p class="text-5xl font-black text-[#00B5E2] tracking-tighter leading-none uppercase">ZERO</p>
                    <p class="text-[10px] font-black text-gray-400 uppercase tracking-widest leading-tight">Incidentes <br/> Críticos</p>
                </div>
            </div>
        </div>
    </Container>

    <style>
        @keyframes scan {
            0% { transform: translateY(-100%); }
            100% { transform: translateY(650px); }
        }
        .animate-scan {
            animation: scan 4s linear infinite;
        }
    </style>

    <script>
        import { gsap } from "gsap";
        import { ScrollTrigger } from "gsap/ScrollTrigger";
        import * as THREE from "three";
        import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass.js';

        gsap.registerPlugin(ScrollTrigger);

        // --- Sophisticated Animations ---
        document.addEventListener("DOMContentLoaded", () => {
            const tl = gsap.timeline({
                scrollTrigger: {
                    trigger: ".features-header",
                    start: "top 95%",
                }
            });

            // Floating "manchas" effect
            gsap.to(".feature-mancha", {
                x: "random(-30, 30)",
                y: "random(-30, 30)",
                scale: "random(0.95, 1.1)",
                duration: "random(7, 12)",
                repeat: -1,
                yoyo: true,
                ease: "sine.inOut"
            });
            
            tl.to(".features-header", { opacity: 1, y: 0, duration: 1.2, ease: "expo.out" })
              .to(".sector-card", {
                  opacity: 1,
                  duration: 1,
                  stagger: 0.1,
                  ease: "power2.out"
              }, "-=0.8")
              .to(".sector-title", {
                  opacity: 1,
                  y: 0,
                  duration: 0.8,
                  stagger: 0.1
              }, "-=1")
              .to(".sector-desc", {
                  opacity: 1,
                  y: 0,
                  duration: 0.8,
                  stagger: 0.1
              }, "-=0.8")
              .to(".features-footer", {
                  opacity: 1,
                  y: 0,
                  duration: 1.2
              }, "-=0.5");

            initThreeEffects();
        });

        function initThreeEffects() {
            const containers = document.querySelectorAll('.feature-visual');
            
            containers.forEach(el => {
                const container = el as HTMLElement;
                const canvas = container.querySelector('.three-canvas') as HTMLCanvasElement;
                const type = container.dataset.visual;
                
                if (!canvas) return;

                const scene = new THREE.Scene();
                // Fog starts far to keep colors neon-bright
                scene.fog = new THREE.Fog(0x001133, 12, 25);

                const camera = new THREE.PerspectiveCamera(50, 1, 0.1, 1000);
                const renderer = new THREE.WebGLRenderer({ canvas, alpha: true, antialias: true });
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.setSize(container.clientWidth, container.clientHeight);
                renderer.setClearColor(0x001133, 1);
                
                // Technical Vantage Point (restored tilt)
                camera.position.set(0, 2.4, 8);
                camera.rotation.x = -0.30; 

                // Post-processing: Master Bloom Glow
                const renderScene = new RenderPass(scene, camera);
                const bloomPass = new UnrealBloomPass(
                    new THREE.Vector2(container.clientWidth, container.clientHeight),
                    1.5, 0.4, 0.85
                );
                bloomPass.threshold = 0.1; 
                bloomPass.strength = 1.8;
                bloomPass.radius = 0.6;

                const composer = new EffectComposer(renderer);
                composer.addPass(renderScene);
                composer.addPass(bloomPass);

                const clock = new THREE.Clock();
                const cyanMat = new THREE.LineBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.85 });
                const whiteMat = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.9 });
                const faintMat = new THREE.LineBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.15 });

                // Raycaster
                const raycaster = new THREE.Raycaster();
                const mouse = new THREE.Vector2(-1, -1);

                const createEdges = (geo: THREE.BufferGeometry, mat: THREE.Material) => {
                    return new THREE.LineSegments(new THREE.EdgesGeometry(geo), mat);
                };

                const createLabel = (text: string, x: number, y: number, z: number, size = 1.2) => {
                    const canv = document.createElement('canvas'); const ctx = canv.getContext('2d')!;
                    canv.width = 512; canv.height = 128;
                    ctx.fillStyle = '#00ffff'; 
                    ctx.font = 'bold 44px "JetBrains Mono", monospace';
                    ctx.textAlign = 'center'; 
                    ctx.fillText(`[ ${text} ]`, 256, 80);
                    const tex = new THREE.CanvasTexture(canv);
                    const spr = new THREE.Sprite(new THREE.SpriteMaterial({ map: tex, transparent: true, opacity: 0.95 }));
                    spr.scale.set(size * 2, size * 0.5, 1); spr.position.set(x, y, z); return spr;
                };

                const root = new THREE.Group();
                root.scale.setScalar(1.6); 
                const baseY = -1; // Base position to sit objects at the bottom
                root.position.y = baseY; 
                scene.add(root);

                // --- Visual Logic for each sector ---
                if (type === 'mes-hub') {
                    const mesh = new THREE.Group();
                    mesh.add(createEdges(new THREE.BoxGeometry(2, 1.4, 1.8), whiteMat));
                    const scada = new THREE.Group();
                    scada.add(createEdges(new THREE.PlaneGeometry(1.4, 0.9), cyanMat));
                    scada.rotation.x = -Math.PI/4; scada.position.set(0, 1.8, 0);
                    mesh.add(scada, createLabel("SYSTEM_ACTIVE", 0, 2.2, 0));

                    const pointsGeo = new THREE.BufferGeometry();
                    const pCount = 35;
                    const pPositions = new Float32Array(pCount * 3);
                    const pSpeeds = new Float32Array(pCount);
                    for(let i=0; i<pCount; i++) {
                        pPositions[i*3] = (Math.random()-0.5)*1.9;
                        pPositions[i*3+1] = -0.5;
                        pPositions[i*3+2] = (Math.random()-0.5)*1.3;
                        pSpeeds[i] = 0.012 + Math.random() * 0.04;
                    }
                    pointsGeo.setAttribute('position', new THREE.BufferAttribute(pPositions, 3));
                    const points = new THREE.Points(pointsGeo, new THREE.PointsMaterial({ color: 0x00ffff, size: 0.05 }));
                    (points as any).speeds = pSpeeds;
                    mesh.add(points);
                    root.add(mesh);

                } else if (type === 'pcb-trace') {
                    const pcb = new THREE.Group();
                    pcb.add(createEdges(new THREE.BoxGeometry(3.6, 0.1, 2.6), faintMat));
                    for(let i=0; i<8; i++) {
                        const comp = createEdges(new THREE.BoxGeometry(0.4, 0.2, 0.4), cyanMat);
                        comp.position.set((Math.random()-0.5)*3.2, 0.15, (Math.random()-0.5)*2.2);
                        pcb.add(comp);
                    }
                    pcb.rotation.x = Math.PI/10;
                    
                    // Ultra-subtle Laser Beam
                    const beam = createEdges(new THREE.CylinderGeometry(0.01, 0.05, 10, 8, 1, true), faintMat);
                    (beam.material as THREE.LineBasicMaterial).opacity = 0.05;
                    beam.position.y = 5; 
                    
                    const probe = new THREE.Group();
                    probe.add(createEdges(new THREE.CylinderGeometry(0.02, 0.02, 3), whiteMat));
                    const tip = createEdges(new THREE.SphereGeometry(0.08, 8, 8), cyanMat);
                    tip.position.y = -1.5; probe.add(tip);
                    probe.position.y = 1.75; // Starting position
                    
                    pcb.add(beam, probe);
                    root.add(pcb, createLabel("QC_TRACE_PASS", 0, 2.2, 0));

                } else if (type === 'scale-flow') {
                    const log = new THREE.Group();
                    log.add(createEdges(new THREE.BoxGeometry(4.2, 0.15, 1.4), whiteMat));
                    const scale = createEdges(new THREE.BoxGeometry(1.4, 0.2, 1.5), cyanMat);
                    scale.position.set(0.6, -0.05, 0); log.add(scale);
                    const box = createEdges(new THREE.BoxGeometry(0.8, 0.8, 0.8), whiteMat);
                    box.position.set(-2.2, 0.5, 0); log.add(box);
                    root.add(log, createLabel("BASCULA_DYN", 0.6, 2.2, 0));

                } else if (type === 'service-stack') {
                    const metal = new THREE.Group();
                    metal.add(createEdges(new THREE.CylinderGeometry(1.6, 1.8, 0.7, 6), whiteMat));
                    const fixture = new THREE.Group();
                    fixture.add(createEdges(new THREE.BoxGeometry(1.5, 1.5, 1.5), cyanMat));
                    fixture.add(createEdges(new THREE.BoxGeometry(1.7, 0.1, 1.7), whiteMat));
                    fixture.position.y = 2.5; metal.add(fixture);
                    root.add(metal, createLabel("ALIGN_0.001mm", 0, 2.2, 0));
                }

                container.addEventListener('mousemove', (e) => {
                    const rect = container.getBoundingClientRect();
                    mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1; mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
                });

                const animate = () => {
                    requestAnimationFrame(animate);
                    const time = clock.getElapsedTime();
                    if (!root || !composer) return;

                    root.position.y = baseY + Math.sin(time * 0.4) * 0.12;
                    root.rotation.y = time * 0.12 + Math.sin(time * 0.2) * 0.06;

                    raycaster.setFromCamera(mouse, camera);
                    const intersects = raycaster.intersectObjects(root.children, true);
                    root.traverse((obj: any) => { 
                        if (obj.isLineSegments && obj.material) obj.material.opacity = 0.55; 
                    });
                    intersects.forEach((hit: any) => { 
                        if (hit.object.isLineSegments && hit.object.material) hit.object.material.opacity = 1.0; 
                    });

                    // Specific View Animations with safety checks
                    try {
                        if (type === 'mes-hub' && root.children[0]?.children[3]) {
                            const pts = root.children[0].children[3] as THREE.Points;
                            const pos = pts.geometry.attributes.position.array as Float32Array;
                            const speeds = (pts as any).speeds;
                            if (speeds) {
                                for(let i=0; i<speeds.length; i++) {
                                    pos[i*3+1] += speeds[i]; if(pos[i*3+1] > 1.8) pos[i*3+1] = -0.6;
                                }
                                pts.geometry.attributes.position.needsUpdate = true;
                            }
                        } else if (type === 'pcb-trace' && root.children[0]?.children[10]) {
                            const pcbGroup = root.children[0];
                            const beam = pcbGroup.children[9];
                            const probe = pcbGroup.children[10];
                            
                            // Navigation logic
                            const compIdx = (Math.floor(time * 0.5) % 8) + 1;
                            const target = pcbGroup.children[compIdx];
                            if (target) {
                                probe.position.x += (target.position.x - probe.position.x) * 0.08;
                                probe.position.z += (target.position.z - probe.position.z) * 0.08;
                                beam.position.x = probe.position.x;
                                beam.position.z = probe.position.z;

                                // Precise touch (Y=1.75 is the contact point for the tip)
                                const offset = Math.abs(Math.cos(time * 1.5)) * 1.8;
                                probe.position.y = 1.75 + offset;
                                (beam as any).material.opacity = offset < 0.1 ? 0.35 : 0.05;
                            }
                        } else if (type === 'scale-flow' && root.children[0]?.children[2]) {
                            const box = root.children[0].children[2];
                            box.position.x += 0.025; if(box.position.x > 2.5) box.position.x = -2.5;
                            box.rotation.y = time * 0.5;
                        } else if (type === 'service-stack' && root.children[0]?.children[1]) {
                            const fixture = root.children[0].children[1];
                            const cycle = (Math.sin(time) + 1) / 2;
                            fixture.position.y = 0.45 + (1 - Math.pow(cycle, 4)) * 2.5; // Snap effect
                        }
                    } catch (e) {
                        // Silent fail for animation frame to avoid console spam
                    }

                    composer.render();
                };
                animate();

                window.addEventListener('resize', () => {
                    if (!container) return;
                    const w = container.clientWidth; const h = container.clientHeight;
                    renderer.setSize(w, h); composer.setSize(w, h); camera.aspect = w / h; camera.updateProjectionMatrix();
                });
            });
        }
    </script>
</section>

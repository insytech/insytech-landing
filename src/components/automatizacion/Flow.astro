---
import FlowNode from "@components/shared/FlowNode.astro";
import RunnerBot from "./RunnerBot.astro";

export interface Props {}

const {} = Astro.props;
---

<div class="automation-flows">
    <!-- Flujo principal central -->
    <div class="flow-container main-flow">
        <FlowNode
            id="node-trigger"
            icon="⚡"
            label="Trigger"
            className="trigger-node"
            animateType="scale"
            animateDelay="0.3s"
        />

        <FlowNode
            id="node-ai"
            icon="🤖"
            label="Agente IA"
            className="ai-node"
            animateType="scale"
            animateDelay="0.9s"
        />

        <FlowNode
            id="node-action"
            icon="⚙️"
            label="Acción"
            className="action-node"
            animateType="scale"
            animateDelay="1.5s"
        />

        <FlowNode
            id="node-notify"
            icon="🔔"
            label="Notificación"
            className="notify-node"
            animateType="scale"
            animateDelay="2.1s"
        />
    </div>

    <!-- Flujo secundario superior -->
    <div class="flow-container secondary-flow top-flow">
        <FlowNode
            id="node-email"
            icon="📧"
            label="Email Marketing"
            size="small"
            animateType="fade-up"
            animateDelay="0.5s"
        />

        <FlowNode
            id="node-chat"
            icon="💬"
            label="Chat Empresarial"
            size="small"
            className="node-5"
            animateType="fade-up"
            animateDelay="0.8s"
        />
    </div>

    <!-- Flujo secundario inferior -->
    <div class="flow-container secondary-flow bottom-flow">
        <FlowNode
            id="node-crm"
            icon="📊"
            label="CRM"
            size="small"
            animateType="fade-up"
            animateDelay="0.7s"
        />
        <FlowNode
            id="node-api"
            icon="🌐"
            label="API"
            size="small"
            animateType="fade-up"
            animateDelay="1s"
        />
    </div>

    <!-- Nodos flotantes -->
    <div class="floating-nodes">
        <FlowNode
            id="node-pipeline"
            icon="🔗"
            label="Pipeline"
            className="floating-node node-1"
            animateType="scale"
            animateDelay="1.8s"
        />

        <FlowNode
            id="node-whatsapp"
            icon="📱"
            label="WhatsApp"
            className="floating-node node-2"
            animateType="scale"
            animateDelay="2.1s"
        />

        <FlowNode
            id="node-targeting"
            icon="🎯"
            label="Targeting"
            className="floating-node node-4"
            animateType="scale"
            animateDelay="2.7s"
        />

        <FlowNode
            id="node-forms"
            icon="📋"
            label="Leads"
            className="floating-node node-3"
            animateType="scale"
            animateDelay="2.4s"
        />
    </div>

    <!-- SVG dinámico para conexiones automáticas -->
    <svg
        id="dynamic-connections-svg"
        class="dynamic-connections-overlay"
        viewBox="0 0 100 100"
        preserveAspectRatio="none"
    >
        <!-- Las conexiones se generarán dinámicamente aquí -->
    </svg>
</div>

<RunnerBot />

<script>
    // Animación mejorada con conexiones dinámicas y runner bot
    document.addEventListener("DOMContentLoaded", () => {
        const heroContainer = document.querySelector(".automation-hero");
        const visualArea = document.querySelector(".hero-visual-area");
        const flowsContainer = document.querySelector(".automation-flows");
        const dynamicContainer = document.getElementById("dynamic-container");
        const runner = document.getElementById("runner");
        const dynamicSvg = document.getElementById("dynamic-connections-svg");

        if (
            !heroContainer ||
            !visualArea ||
            !flowsContainer ||
            !dynamicContainer ||
            !runner ||
            !dynamicSvg
        )
            return;

        const flow = [
            "node-trigger",
            "node-ai",
            "node-action",
            "node-pipeline",
            "node-email",
            "node-pipeline",
            "node-chat",
            "node-action",
            "node-whatsapp",
            "node-api",
            "node-crm",
            "node-action",
            "node-targeting",
            "node-forms",
            "node-action",
            "node-notify",
            "node-trigger",
        ];

        const nodes = Object.fromEntries(
            flow
                .map((id) => [id, document.getElementById(id)])
                .filter(([id, el]) => el),
        );

        const getRect = (el: { getBoundingClientRect: () => any }) =>
            el.getBoundingClientRect();

        // CORREGIR: Usar el área visual como contenedor de referencia en lugar del hero completo
        const getContainerRect = () => {
            // Usar el área visual como referencia para coordenadas más precisas
            return visualArea.getBoundingClientRect();
        };

        // CORREGIR: Función center mejorada con mejor precisión
        const center = (el: any) => {
            const containerRect = getContainerRect();
            const elRect = getRect(el);
            return {
                x: elRect.left - containerRect.left + elRect.width / 2,
                y: elRect.top - containerRect.top + elRect.height / 2,
            };
        };

        // CORREGIR: Función mejorada para línea de movimiento
        let currentTrail: HTMLDivElement | null = null;

        const createMovementTrail = (fromNode: any, toNode: any) => {
            // Limpiar línea anterior
            if (currentTrail) {
                currentTrail.remove();
                currentTrail = null;
            }

            const fromPos = center(fromNode);
            const toPos = center(toNode);

            // Crear una línea simple con CSS
            const trail = document.createElement("div");
            trail.className = "movement-trail";

            // Calcular ángulo y distancia
            const dx = toPos.x - fromPos.x;
            const dy = toPos.y - fromPos.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const angle = (Math.atan2(dy, dx) * 180) / Math.PI;

            // CORREGIR: Posicionar la línea relativa al área visual
            trail.style.left = `${fromPos.x}px`;
            trail.style.top = `${fromPos.y}px`;
            trail.style.width = `${distance}px`;
            trail.style.transform = `rotate(${angle}deg)`;
            trail.style.transformOrigin = "0 50%";

            // Usar el contenedor dedicado
            dynamicContainer.appendChild(trail);
            currentTrail = trail;

            // Animar la línea
            setTimeout(() => trail.classList.add("active"), 10);

            return trail;
        };

        // CORREGIR: Funciones del runner con coordenadas relativas al área visual
        const setRunnerPosition = (x: number, y: number) => {
            // IMPORTANTE: Las coordenadas ya son relativas al área visual
            runner.style.left = `${x}px`;
            runner.style.top = `${y}px`;
            runner.style.transform = `translate(-50%, -50%)`;
        };

        const setRunnerDirection = (dx: number, dy: number) => {
            const angle = Math.atan2(dy, dx);
            runner.style.setProperty("--rotation", `${angle}rad`);
        };

        const moveRunner = (fromId: string, toId: string, speed = 600) => {
            return new Promise<void>((resolve) => {
                const fromNode = nodes[fromId];
                const toNode = nodes[toId];
                if (!fromNode || !toNode) return resolve();

                // Crear línea de movimiento
                const trail = createMovementTrail(fromNode, toNode);

                const fromPos = center(fromNode);
                const toPos = center(toNode);
                const dx = toPos.x - fromPos.x;
                const dy = toPos.y - fromPos.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                setRunnerDirection(dx, dy);

                const duration = Math.max(400, (distance / speed) * 1000);
                const startTime = performance.now();

                runner.classList.add("moving");

                const animate = (currentTime: number) => {
                    const elapsed = currentTime - startTime;
                    const progress = Math.min(elapsed / duration, 1);

                    const eased =
                        progress < 0.5
                            ? 2 * progress * progress
                            : 1 - Math.pow(-2 * progress + 2, 3) / 2;

                    const currentX = fromPos.x + dx * eased;
                    const currentY = fromPos.y + dy * eased;

                    setRunnerPosition(currentX, currentY);

                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        runner.classList.remove("moving");
                        // Ocultar línea después del movimiento
                        setTimeout(() => {
                            if (trail && trail.parentNode) {
                                trail.classList.remove("active");
                                setTimeout(() => {
                                    if (trail.parentNode) {
                                        trail.parentNode.removeChild(trail);
                                    }
                                }, 300);
                            }
                        }, 200);
                        resolve();
                    }
                };

                requestAnimationFrame(animate);
            });
        };

        const pressNode = async (nodeId: string) => {
            const node = nodes[nodeId];
            if (!node) return;

            node.classList.add("pressed");
            await new Promise((resolve) => setTimeout(resolve, 300));
            node.classList.remove("pressed");
        };

        // Sistema de conexiones refinado para mejor visualización
        const connections = [
            {
                from: "node-trigger",
                to: "node-ai",
                type: "line",
                importance: "primary",
            },
            {
                from: "node-ai",
                to: "node-action",
                type: "line",
                importance: "primary",
            },
            {
                from: "node-action",
                to: "node-notify",
                type: "line",
                importance: "primary",
            },
            {
                from: "node-action",
                to: "node-pipeline",
                type: "line",
                importance: "primary",
            },
            {
                from: "node-pipeline",
                to: "node-email",
                type: "curve",
                importance: "secondary",
            },
            {
                from: "node-pipeline",
                to: "node-chat",
                type: "curve",
                importance: "secondary",
            },
            {
                from: "node-action",
                to: "node-whatsapp",
                type: "line",
                importance: "secondary",
            },
            {
                from: "node-whatsapp",
                to: "node-api",
                type: "curve",
                importance: "tertiary",
            },
            {
                from: "node-api",
                to: "node-crm",
                type: "line",
                importance: "tertiary",
            },
            {
                from: "node-action",
                to: "node-targeting",
                type: "line",
                importance: "secondary",
            },
            {
                from: "node-targeting",
                to: "node-forms",
                type: "curve",
                importance: "tertiary",
            },
        ];

        // Función mejorada para crear conexiones con estética profesional
        const createDynamicConnections = () => {
            dynamicSvg.innerHTML = "";
            // CORREGIR: Usar el contenedor de flows como referencia para las conexiones SVG
            const flowsRect = flowsContainer.getBoundingClientRect();

            if (!flowsRect) return;

            // Ordenar conexiones por importancia para que las primarias estén encima
            const sortedConnections = [...connections].sort((a, b) => {
                const importanceOrder = {
                    primary: 3,
                    secondary: 2,
                    tertiary: 1,
                };
                return (
                    importanceOrder[b.importance] -
                    importanceOrder[a.importance]
                );
            });

            // Crear un filtro de glow una sola vez para todas las líneas
            const defs = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "defs",
            );

            // Crear tres filtros diferentes para cada tipo de importancia
            ["primary", "secondary", "tertiary"].forEach((importance, i) => {
                const glowColor =
                    importance === "primary"
                        ? "rgba(6, 255, 165, 0.6)"
                        : importance === "secondary"
                          ? "rgba(0, 181, 226, 0.5)"
                          : "rgba(139, 92, 246, 0.4)";

                const filterId = `glow-${importance}`;
                const filter = document.createElementNS(
                    "http://www.w3.org/2000/svg",
                    "filter",
                );
                filter.setAttribute("id", filterId);
                filter.setAttribute("x", "-50%");
                filter.setAttribute("y", "-50%");
                filter.setAttribute("width", "200%");
                filter.setAttribute("height", "200%");

                const feGaussianBlur = document.createElementNS(
                    "http://www.w3.org/2000/svg",
                    "feGaussianBlur",
                );
                feGaussianBlur.setAttribute("stdDeviation", "2");
                feGaussianBlur.setAttribute("result", "blur");

                const feColorMatrix = document.createElementNS(
                    "http://www.w3.org/2000/svg",
                    "feColorMatrix",
                );
                feColorMatrix.setAttribute("in", "blur");
                feColorMatrix.setAttribute("type", "matrix");
                feColorMatrix.setAttribute(
                    "values",
                    "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 18 -7",
                );
                feColorMatrix.setAttribute("result", "glow");

                const feFlood = document.createElementNS(
                    "http://www.w3.org/2000/svg",
                    "feFlood",
                );
                feFlood.setAttribute("flood-color", glowColor);
                feFlood.setAttribute("result", "color");

                const feComposite = document.createElementNS(
                    "http://www.w3.org/2000/svg",
                    "feComposite",
                );
                feComposite.setAttribute("in", "color");
                feComposite.setAttribute("in2", "glow");
                feComposite.setAttribute("operator", "in");
                feComposite.setAttribute("result", "coloredGlow");

                const feMerge = document.createElementNS(
                    "http://www.w3.org/2000/svg",
                    "feMerge",
                );

                const feMergeNode1 = document.createElementNS(
                    "http://www.w3.org/2000/svg",
                    "feMergeNode",
                );
                feMergeNode1.setAttribute("in", "coloredGlow");

                const feMergeNode2 = document.createElementNS(
                    "http://www.w3.org/2000/svg",
                    "feMergeNode",
                );
                feMergeNode2.setAttribute("in", "SourceGraphic");

                feMerge.appendChild(feMergeNode1);
                feMerge.appendChild(feMergeNode2);

                filter.appendChild(feGaussianBlur);
                filter.appendChild(feColorMatrix);
                filter.appendChild(feFlood);
                filter.appendChild(feComposite);
                filter.appendChild(feMerge);

                defs.appendChild(filter);
            });

            dynamicSvg.appendChild(defs);

            sortedConnections.forEach(
                ({ from, to, type, importance }, index) => {
                    const fromNode = document.getElementById(from);
                    const toNode = document.getElementById(to);

                    if (!fromNode || !toNode) return;

                    const fromRect = fromNode.getBoundingClientRect();
                    const toRect = toNode.getBoundingClientRect();

                    // CORREGIR: Calcular posiciones relativas al contenedor de flows
                    const fromWidth = fromRect.width;
                    const fromHeight = fromRect.height;
                    const toWidth = toRect.width;
                    const toHeight = toRect.height;

                    const fromCenterX =
                        ((fromRect.left - flowsRect.left + fromWidth / 2) /
                            flowsRect.width) *
                        100;
                    const fromCenterY =
                        ((fromRect.top - flowsRect.top + fromHeight / 2) /
                            flowsRect.height) *
                        100;
                    const toCenterX =
                        ((toRect.left - flowsRect.left + toWidth / 2) /
                            flowsRect.width) *
                        100;
                    const toCenterY =
                        ((toRect.top - flowsRect.top + toHeight / 2) /
                            flowsRect.height) *
                        100;

                    // Calcular puntos de bordes para conexión en lugar de centro a centro
                    const fromWidthPercent =
                        (fromWidth / flowsRect.width) * 100;
                    const fromHeightPercent =
                        (fromHeight / flowsRect.height) * 100;
                    const toWidthPercent = (toWidth / flowsRect.width) * 100;
                    const toHeightPercent = (toHeight / flowsRect.height) * 100;

                    // Calcular vectores y ángulos para las conexiones
                    const dx = toCenterX - fromCenterX;
                    const dy = toCenterY - fromCenterY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const angle = Math.atan2(dy, dx);

                    // Determinar los puntos exactos de intersección con los bordes de los nodos
                    let fromX, fromY, toX, toY;

                    // Para conexiones de tipo línea, mejorar los puntos de inicio y fin
                    if (type === "line") {
                        // Obtener las coordenadas reales del borde del nodo de origen
                        const halfWidthFrom = fromWidthPercent / 2;
                        const halfHeightFrom = fromHeightPercent / 2;
                        const halfWidthTo = toWidthPercent / 2;
                        const halfHeightTo = toHeightPercent / 2;

                        // Calcular los factores de escala para la intersección con el rectángulo
                        const fromScaleX =
                            Math.abs(Math.cos(angle)) < 0.001
                                ? Infinity
                                : halfWidthFrom / Math.abs(Math.cos(angle));
                        const fromScaleY =
                            Math.abs(Math.sin(angle)) < 0.001
                                ? Infinity
                                : halfHeightFrom / Math.abs(Math.sin(angle));
                        const toScaleX =
                            Math.abs(Math.cos(angle)) < 0.001
                                ? Infinity
                                : halfWidthTo / Math.abs(Math.cos(angle));
                        const toScaleY =
                            Math.abs(Math.sin(angle)) < 0.001
                                ? Infinity
                                : halfHeightTo / Math.abs(Math.sin(angle));

                        // Tomar el factor de escala más pequeño para la intersección
                        const fromScale = Math.min(fromScaleX, fromScaleY);
                        const toScale = Math.min(toScaleX, toScaleY);

                        // Calcular los puntos de intersección exactos
                        fromX = fromCenterX + Math.cos(angle) * fromScale;
                        fromY = fromCenterY + Math.sin(angle) * fromScale;
                        toX = toCenterX - Math.cos(angle) * toScale;
                        toY = toCenterY - Math.sin(angle) * toScale;

                        // Ajuste fino para evitar problemas con ángulos extremos
                        if (
                            isNaN(fromX) ||
                            isNaN(fromY) ||
                            isNaN(toX) ||
                            isNaN(toY)
                        ) {
                            fromX = fromCenterX + Math.sign(dx) * halfWidthFrom;
                            fromY =
                                fromCenterY + Math.sign(dy) * halfHeightFrom;
                            toX = toCenterX - Math.sign(dx) * halfWidthTo;
                            toY = toCenterY - Math.sign(dy) * halfHeightTo;
                        }
                    } else {
                        // Para curvas, usar la aproximación anterior que funciona bien
                        if (
                            Math.abs(Math.cos(angle)) >
                            Math.abs(Math.sin(angle))
                        ) {
                            fromX =
                                fromCenterX +
                                (Math.sign(dx) * fromWidthPercent) / 2;
                            fromY =
                                fromCenterY +
                                (Math.tan(angle) *
                                    Math.sign(dx) *
                                    fromWidthPercent) /
                                    2;

                            toX =
                                toCenterX -
                                (Math.sign(dx) * toWidthPercent) / 2;
                            toY =
                                toCenterY -
                                (Math.tan(angle) *
                                    Math.sign(dx) *
                                    toWidthPercent) /
                                    2;
                        } else {
                            fromY =
                                fromCenterY +
                                (Math.sign(dy) * fromHeightPercent) / 2;
                            fromX =
                                fromCenterX +
                                (Math.sign(dy) * fromHeightPercent) /
                                    2 /
                                    Math.tan(angle);

                            toY =
                                toCenterY -
                                (Math.sign(dy) * toHeightPercent) / 2;
                            toX =
                                toCenterX -
                                (Math.sign(dy) * toHeightPercent) /
                                    2 /
                                    Math.tan(angle);
                        }

                        // Prevenir NaN
                        if (
                            isNaN(fromX) ||
                            isNaN(fromY) ||
                            isNaN(toX) ||
                            isNaN(toY)
                        ) {
                            fromX = fromCenterX;
                            fromY = fromCenterY;
                            toX = toCenterX;
                            toY = toCenterY;
                        }
                    }

                    // Crear el grupo para contener la línea
                    const pathGroup = document.createElementNS(
                        "http://www.w3.org/2000/svg",
                        "g",
                    );
                    pathGroup.setAttribute(
                        "class",
                        `path-group ${importance}-connection`,
                    );

                    // Crear la línea de conexión
                    const path = document.createElementNS(
                        "http://www.w3.org/2000/svg",
                        "path",
                    );
                    let pathData = "";

                    // Generar path según tipo
                    if (type === "curve") {
                        // Calcular puntos de control para curva Bézier cúbica
                        const curveFactor = Math.min(
                            Math.max(distance * 0.2, 8),
                            35,
                        );
                        const midX = (fromX + toX) / 2;
                        const midY = (fromY + toY) / 2;

                        // Ajustar dirección de curvatura según posición relativa
                        let controlX1, controlY1, controlX2, controlY2;

                        if (fromCenterY > toCenterY) {
                            controlX1 = fromX + (toX - fromX) * 0.25;
                            controlY1 = fromY - curveFactor;
                            controlX2 = fromX + (toX - fromX) * 0.75;
                            controlY2 = toY - curveFactor;
                        } else {
                            controlX1 = fromX + (toX - fromX) * 0.25;
                            controlY1 = fromY + curveFactor;
                            controlX2 = fromX + (toX - fromX) * 0.75;
                            controlY2 = toY + curveFactor;
                        }

                        // Si la línea es principalmente horizontal, ajustar controles
                        if (Math.abs(dx) > Math.abs(dy) * 2) {
                            controlY1 =
                                fromY + Math.sign(dy) * curveFactor * 0.5;
                            controlY2 = toY + Math.sign(dy) * curveFactor * 0.5;
                        }

                        pathData = `M ${fromX} ${fromY} C ${controlX1} ${controlY1}, ${controlX2} ${controlY2}, ${toX} ${toY}`;
                    } else {
                        // Para líneas rectas, añadir un ligero efecto de curva para mayor elegancia
                        const straightOffset = Math.min(distance * 0.05, 3); // Curvatura muy sutil

                        // Calcular punto de control para una curva cuadrática muy sutil
                        const controlX = (fromX + toX) / 2;
                        const controlY = (fromY + toY) / 2 - straightOffset;

                        // Usar curva cuadrática sutil en lugar de línea recta
                        pathData = `M ${fromX} ${fromY} Q ${controlX} ${controlY}, ${toX} ${toY}`;
                    }

                    path.setAttribute("id", `connection-path-${index}`);
                    path.setAttribute("d", pathData);
                    path.setAttribute(
                        "class",
                        `dynamic-connection-path ${importance}-path ${type}-path`,
                    );

                    // Aplicar filtro de glow según importancia
                    path.setAttribute("filter", `url(#glow-${importance})`);

                    // Grosor según importancia
                    const baseWidth =
                        importance === "primary"
                            ? 1.2
                            : importance === "secondary"
                              ? 0.8
                              : 0.5;
                    path.setAttribute("stroke-width", baseWidth.toString());

                    // Gradiente para la línea
                    const gradientId = `lineGradient-${index}`;
                    const linearGradient = document.createElementNS(
                        "http://www.w3.org/2000/svg",
                        "linearGradient",
                    );
                    linearGradient.setAttribute("id", gradientId);

                    // Alinear el gradiente con la dirección de la línea
                    if (fromX !== toX || fromY !== toY) {
                        const normX = dx / distance;
                        const normY = dy / distance;
                        linearGradient.setAttribute(
                            "gradientTransform",
                            `rotate(${(Math.atan2(normY, normX) * 180) / Math.PI}, 0.5, 0.5)`,
                        );
                    }

                    linearGradient.setAttribute("x1", "0%");
                    linearGradient.setAttribute("y1", "0%");
                    linearGradient.setAttribute("x2", "100%");
                    linearGradient.setAttribute("y2", "0%");

                    // Colores según importancia con mejores gradientes
                    const colors = {
                        primary: ["#06ffa5", "#00b5e2"],
                        secondary: ["#00b5e2", "#0066ff"],
                        tertiary: ["#a78bfa", "#8b5cf6"],
                    };

                    const [color1, color2] = colors[importance];

                    const stop1 = document.createElementNS(
                        "http://www.w3.org/2000/svg",
                        "stop",
                    );
                    stop1.setAttribute("offset", "0%");
                    stop1.setAttribute("stop-color", color1);

                    const stop2 = document.createElementNS(
                        "http://www.w3.org/2000/svg",
                        "stop",
                    );
                    stop2.setAttribute("offset", "100%");
                    stop2.setAttribute("stop-color", color2);

                    linearGradient.appendChild(stop1);
                    linearGradient.appendChild(stop2);
                    defs.appendChild(linearGradient);

                    path.setAttribute("stroke", `url(#${gradientId})`);
                    path.setAttribute("fill", "none");

                    pathGroup.appendChild(path);

                    // Partículas para líneas primarias y secundarias
                    if (importance !== "tertiary") {
                        const count = importance === "primary" ? 2 : 1;

                        for (let i = 0; i < count; i++) {
                            const particle = document.createElementNS(
                                "http://www.w3.org/2000/svg",
                                "circle",
                            );
                            particle.setAttribute(
                                "r",
                                importance === "primary" ? "0.9" : "0.6",
                            );
                            particle.setAttribute(
                                "fill",
                                importance === "primary"
                                    ? "#06ffa5"
                                    : "#00b5e2",
                            );
                            particle.setAttribute("class", "data-particle");

                            const animateMotion = document.createElementNS(
                                "http://www.w3.org/2000/svg",
                                "animateMotion",
                            );
                            animateMotion.setAttribute(
                                "dur",
                                `${4 + Math.random() * 3}s`,
                            );
                            animateMotion.setAttribute(
                                "repeatCount",
                                "indefinite",
                            );
                            animateMotion.setAttribute(
                                "begin",
                                `${index * 0.3 + i * 2}s`,
                            );
                            animateMotion.setAttribute("calcMode", "spline");
                            animateMotion.setAttribute(
                                "keySplines",
                                ".42,0,.58,1",
                            );

                            const mpath = document.createElementNS(
                                "http://www.w3.org/2000/svg",
                                "mpath",
                            );
                            mpath.setAttribute(
                                "href",
                                `#connection-path-${index}`,
                            );

                            animateMotion.appendChild(mpath);
                            particle.appendChild(animateMotion);
                            pathGroup.appendChild(particle);
                        }
                    }

                    dynamicSvg.appendChild(pathGroup);
                },
            );
        };

        // NUEVO: Actualizar conexiones dinámicas
        const updateDynamicConnections = () => {
            requestAnimationFrame(() => {
                createDynamicConnections();
            });
        };

        // CORREGIR: Loop principal simplificado
        const runFlowLoop = async () => {
            // Esperar un momento para asegurar que el layout esté completo
            await new Promise((resolve) => setTimeout(resolve, 100));

            const firstNode = nodes[flow[0]];
            if (firstNode) {
                const pos = center(firstNode);
                setRunnerPosition(pos.x, pos.y);

                runner.style.opacity = "1";
                runner.style.visibility = "visible";

                // Crear conexiones dinámicas iniciales
                createDynamicConnections();

                await pressNode(flow[0]);
            }

            while (true) {
                for (let i = 0; i < flow.length - 1; i++) {
                    const fromId = flow[i];
                    const toId = flow[i + 1];

                    await moveRunner(fromId, toId);
                    await pressNode(toId);
                    await new Promise((resolve) => setTimeout(resolve, 300));
                }
            }
        };

        // Inicializar
        runFlowLoop();

        // CORREGIR: Actualizar coordenadas en resize
        let resizeTimeout: string | number | NodeJS.Timeout | undefined;
        window.addEventListener("resize", () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                // Recalcular posición del runner
                const firstNode = nodes[flow[0]];
                if (firstNode) {
                    const pos = center(firstNode);
                    setRunnerPosition(pos.x, pos.y);
                }
                // Actualizar conexiones dinámicas
                updateDynamicConnections();
            }, 100);
        });

        // Observer para cambios en el layout
        const resizeObserver = new ResizeObserver(() => {
            updateDynamicConnections();
        });

        // Observar cambios en el área visual y contenedor de flows
        if (visualArea) resizeObserver.observe(visualArea);
        if (flowsContainer) resizeObserver.observe(flowsContainer);

        // Observar cambios en los nodos principales
        ["node-action", "node-email", "node-crm"].forEach((id) => {
            const element = document.getElementById(id);
            if (element) {
                resizeObserver.observe(element);
            }
        });
    });
</script>

<style>
    :root {
        --primary: #0066ff;
        --accent: #00b5e2;
        --success: #06ffa5;
        --tertiary: #8b5cf6;
    }

    /* Flujos de automatización - expandido */
    .automation-flows {
        position: relative;
        width: 100%;
        height: 500px; /* Aumentado de 400px a 500px */
        pointer-events: none;
        z-index: 5;
        margin: 0 auto;
    }

    .flow-container {
        position: absolute;
        display: flex;
        align-items: center;
        gap: 3rem; /* Aumentado el gap entre nodos */
    }

    .main-flow {
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        flex-direction: row;
        gap: 2.5rem; /* Aumentado el gap */
        width: 85%; /* Reducido para dar más margen */
        justify-content: space-between;
    }

    .top-flow {
        top: 10%; /* Ajustado para mejor distribución */
        right: 8%;
        flex-direction: row;
        gap: 2.5rem; /* Aumentado */
    }

    .bottom-flow {
        bottom: 10%; /* Ajustado para mejor distribución */
        left: 8%;
        flex-direction: row;
        gap: 2.5rem; /* Aumentado */
    }

    /* SVG dinámico para conexiones */
    .dynamic-connections-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 4;
        overflow: visible;
    }

    /* Estilos refinados para conexiones */
    .dynamic-connection-path {
        stroke-linecap: round;
        stroke-linejoin: round;
        fill: none;
        transition: all 0.8s ease;
    }

    /* Estilos refinados según importancia */
    .primary-path {
        stroke-dasharray: 12 4;
        animation: flowPrimary 30s linear infinite;
        opacity: 0.85;
    }

    .secondary-path {
        stroke-dasharray: 8 4;
        animation: flowSecondary 40s linear infinite;
        opacity: 0.7;
    }

    .tertiary-path {
        stroke-dasharray: 4 4;
        animation: flowTertiary 60s linear infinite;
        opacity: 0.5;
    }

    /* Estilos específicos por tipo de conexión */
    .line-path {
        stroke-dasharray: 10 4;
    }

    .curve-path {
        stroke-dasharray: 8 5;
    }

    @keyframes flowPrimary {
        to {
            stroke-dashoffset: -48;
        }
    }

    @keyframes flowSecondary {
        to {
            stroke-dashoffset: -36;
        }
    }

    @keyframes flowTertiary {
        to {
            stroke-dashoffset: -24;
        }
    }

    /* Partículas de datos mejoradas */
    .data-particle {
        filter: drop-shadow(0 0 3px currentColor);
        opacity: 0.8;
    }

    /* Transición suave al hacer hover en la zona */
    .automation-flows:hover .dynamic-connection-path.primary-path {
        opacity: 1;
        stroke-width: 1.5;
    }

    .automation-flows:hover .dynamic-connection-path.secondary-path {
        opacity: 0.9;
        stroke-width: 1;
    }

    .automation-flows:hover .data-particle {
        opacity: 1;
    }

    /* Responsive refinado */
    @media (min-width: 1200px) {
        .automation-flows {
            height: 600px; /* Aún más altura en pantallas grandes */
        }

        .main-flow {
            gap: 4rem; /* Más espacio entre nodos */
            width: 80%;
        }

        .top-flow,
        .bottom-flow {
            gap: 3.5rem;
        }
    }

    @media (min-width: 1440px) {
        .automation-flows {
            height: 700px; /* Máxima altura para pantallas muy grandes */
        }

        .main-flow {
            gap: 5rem; /* Máximo espacio entre nodos */
        }
    }

    @media (min-width: 1024px) and (max-width: 1199px) {
        .automation-flows {
            height: 550px; /* Altura intermedia */
        }

        .main-flow {
            gap: 3.5rem;
            width: 82%;
        }

        .top-flow,
        .bottom-flow {
            gap: 3rem;
        }
    }

    @media (max-width: 1024px) {
        .automation-flows {
            position: absolute;
            top: 0;
            right: 0;
            width: 100%;
            height: 100%;
        }

        .main-flow {
            top: 45%;
            left: 50%;
            transform: translate(-50%, -50%);
            gap: 2rem;
            width: 95%;
        }

        .top-flow {
            top: 10%;
            right: 5%;
            gap: 2rem;
        }

        .bottom-flow {
            bottom: 10%;
            left: 5%;
            gap: 2rem;
        }
    }

    @media (max-width: 768px) {
        .automation-flows {
            height: 85%;
            top: 5%;
        }

        .flow-container {
            gap: 1.2rem;
        }

        .main-flow {
            width: 100%;
            justify-content: space-around;
            gap: 0;
            padding: 0 1rem;
        }

        .top-flow {
            right: 2%;
            top: 12%;
            gap: 1rem;
        }

        .bottom-flow {
            left: 2%;
            bottom: 12%;
            gap: 1rem;
        }

        .floating-node {
            display: none;
        }

        /* Redimensionar nodos para móviles */
        .flow-node {
            padding: 0.8rem 0.7rem;
            min-width: 65px;
            transform: scale(0.85);
        }

        .small-node {
            min-width: 55px;
            padding: 0.7rem 0.6rem;
            transform: scale(0.8);
        }

        .node-icon {
            font-size: 1.4rem;
        }

        .small-node .node-icon {
            font-size: 1.1rem;
        }

        .node-label {
            font-size: 0.7rem;
            max-width: 70px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Ajustes para conexiones en móvil */
        .dynamic-connection-path {
            stroke-width: 1 !important;
            opacity: 0.7;
        }

        .primary-path {
            opacity: 0.8;
            stroke-dasharray: 6 3;
        }

        .secondary-path {
            opacity: 0.6;
            stroke-dasharray: 4 3;
        }

        .tertiary-path {
            opacity: 0.5;
            stroke-dasharray: 3 3;
        }

        .data-particle {
            r: 0.6 !important;
        }

        /* Optimizar performance en móviles */
        @keyframes flowPrimary {
            to {
                stroke-dashoffset: -36;
            }
        }

        @keyframes flowSecondary {
            to {
                stroke-dashoffset: -28;
            }
        }

        @keyframes flowTertiary {
            to {
                stroke-dashoffset: -18;
            }
        }
    }

    /* Ajustes específicos para dispositivos muy pequeños */
    @media (max-width: 480px) {
        .automation-flows {
            transform: scale(0.9);
            transform-origin: center center;
        }

        .main-flow {
            flex-wrap: wrap;
            justify-content: center;
            padding-top: 2rem;
            gap: 1rem;
        }

        .top-flow {
            top: 8%;
            right: 5%;
        }

        .bottom-flow {
            left: 5%;
            bottom: 8%;
        }

        .flow-node {
            margin: 0 0.4rem 0.8rem;
            transform: scale(0.8);
        }

        /* Ocultar algunas conexiones menos importantes */
        .tertiary-path {
            display: none;
        }

        /* Reducir efecto visual de glow */
        [filter*="glow"] {
            filter: none !important;
        }
    }

    /* Ajustes para altura reducida */
    @media (max-height: 600px) {
        .automation-flows {
            height: 90vh;
        }

        .top-flow {
            top: 15%;
        }

        .bottom-flow {
            bottom: 15%;
        }

        .main-flow {
            top: 50%;
        }
    }
</style>

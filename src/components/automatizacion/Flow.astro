---
import FlowNode from "@components/shared/FlowNode.astro";
import RunnerBot from "./RunnerBot.astro";

export interface Props {}

const {} = Astro.props;
---

<div class="automation-flows">
    <!-- Flujo principal central -->
    <div class="flow-container main-flow">
        <FlowNode
            id="node-trigger"
            icon="‚ö°"
            label="Trigger"
            className="trigger-node"
            animateType="scale"
            animateDelay="0.3s"
        />

        <FlowNode
            id="node-ai"
            icon="ü§ñ"
            label="AI Agent"
            className="ai-node"
            animateType="scale"
            animateDelay="0.9s"
        />

        <FlowNode
            id="node-action"
            icon="‚öôÔ∏è"
            label="Acci√≥n"
            className="action-node"
            animateType="scale"
            animateDelay="1.5s"
        />

        <FlowNode
            id="node-notify"
            icon="üîî"
            label="Notify"
            className="notify-node"
            animateType="scale"
            animateDelay="2.1s"
        />
    </div>

    <!-- Flujo secundario superior -->
    <div class="flow-container secondary-flow top-flow">
        <FlowNode
            id="node-email"
            icon="üìß"
            label="Email"
            size="small"
            animateType="fade-up"
            animateDelay="0.5s"
        />

        <FlowNode
            id="node-chat"
            icon="üí¨"
            label="Chat"
            size="small"
            animateType="fade-up"
            animateDelay="0.8s"
        />
    </div>

    <!-- Flujo secundario inferior -->
    <div class="flow-container secondary-flow bottom-flow">
        <FlowNode
            id="node-crm"
            icon="üìä"
            label="CRM"
            size="small"
            animateType="fade-up"
            animateDelay="0.7s"
        />

        <FlowNode
            id="node-api"
            icon="üîî"
            label="API"
            size="small"
            animateType="fade-up"
            animateDelay="1s"
        />
    </div>

    <!-- Nodos flotantes -->
    <div class="floating-nodes">
        <FlowNode
            id="node-pipeline"
            icon="üåê"
            label="Pipeline"
            className="floating-node node-1"
            animateType="scale"
            animateDelay="1.8s"
        />

        <FlowNode
            id="node-whatsapp"
            icon="üì±"
            label="WhatsApp"
            className="floating-node node-2"
            animateType="scale"
            animateDelay="2.1s"
        />

        <FlowNode
            id="node-targeting"
            icon="üéØ"
            label="Targeting"
            className="floating-node node-4"
            animateType="scale"
            animateDelay="2.7s"
        />

        <FlowNode
            id="node-forms"
            icon="üìã"
            label="Forms"
            className="floating-node node-3"
            animateType="scale"
            animateDelay="2.4s"
        />
    </div>

    <!-- SVG din√°mico para conexiones autom√°ticas -->
    <svg
        id="dynamic-connections-svg"
        class="dynamic-connections-overlay"
        viewBox="0 0 100 100"
        preserveAspectRatio="none"
    >
        <!-- Las conexiones se generar√°n din√°micamente aqu√≠ -->
    </svg>
</div>

<RunnerBot />

<script>
    // Animaci√≥n mejorada con conexiones din√°micas y runner bot
    document.addEventListener("DOMContentLoaded", () => {
        const heroContainer = document.querySelector(".automation-hero");
        const dynamicContainer = document.getElementById("dynamic-container");
        const runner = document.getElementById("runner");
        const dynamicSvg = document.getElementById("dynamic-connections-svg");

        if (!heroContainer || !dynamicContainer || !runner || !dynamicSvg)
            return;

        const flow = [
            "node-trigger",
            "node-ai",
            "node-action",
            "node-pipeline",
            "node-email",
            "node-pipeline",
            "node-chat",
            "node-action",
            "node-whatsapp",
            "node-crm",
            "node-api",
            "node-action",
            "node-targeting",
            "node-forms",
            "node-action",
            "node-notify",
            "node-trigger",
        ];

        const nodes = Object.fromEntries(
            flow
                .map((id) => [id, document.getElementById(id)])
                .filter(([id, el]) => el),
        );

        const getRect = (el: { getBoundingClientRect: () => any }) =>
            el.getBoundingClientRect();
        const getContainerRect = () => heroContainer.getBoundingClientRect();

        // CORREGIR: Funci√≥n center mejorada
        const center = (el: any) => {
            const containerRect = getContainerRect();
            const elRect = getRect(el);
            return {
                x: elRect.left - containerRect.left + elRect.width / 2,
                y: elRect.top - containerRect.top + elRect.height / 2,
            };
        };

        // CORREGIR: Funci√≥n mejorada para l√≠nea de movimiento
        let currentTrail: HTMLDivElement | null = null;

        const createMovementTrail = (fromNode: any, toNode: any) => {
            // Limpiar l√≠nea anterior
            if (currentTrail) {
                currentTrail.remove();
                currentTrail = null;
            }

            const fromPos = center(fromNode);
            const toPos = center(toNode);

            // Crear una l√≠nea simple con CSS
            const trail = document.createElement("div");
            trail.className = "movement-trail";

            // Calcular √°ngulo y distancia
            const dx = toPos.x - fromPos.x;
            const dy = toPos.y - fromPos.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const angle = (Math.atan2(dy, dx) * 180) / Math.PI;

            // Posicionar la l√≠nea
            trail.style.left = `${fromPos.x}px`;
            trail.style.top = `${fromPos.y}px`;
            trail.style.width = `${distance}px`;
            trail.style.transform = `rotate(${angle}deg)`;
            trail.style.transformOrigin = "0 50%";

            // CAMBIO CR√çTICO: Usar el contenedor dedicado
            dynamicContainer.appendChild(trail);
            currentTrail = trail;

            // Animar la l√≠nea
            setTimeout(() => trail.classList.add("active"), 10);

            return trail;
        };

        // ALTERNATIVA: Si el problema persiste, usar requestAnimationFrame para evitar reflows
        const safeAppendTrail = (trail: HTMLElement) => {
            requestAnimationFrame(() => {
                dynamicContainer.appendChild(trail);
                requestAnimationFrame(() => {
                    trail.classList.add("active");
                });
            });
        };

        // CORREGIR: Funciones del runner con mejor precisi√≥n
        const setRunnerPosition = (x: number, y: number) => {
            // CAMBIO: Usar left/top en lugar de transform3d para posicionamiento inicial
            runner.style.left = `${x}px`;
            runner.style.top = `${y}px`;
            runner.style.transform = `translate(-50%, -50%)`;
        };

        const setRunnerDirection = (dx: number, dy: number) => {
            const angle = Math.atan2(dy, dx);
            runner.style.setProperty("--rotation", `${angle}rad`);
        };

        const moveRunner = (fromId: string, toId: string, speed = 600) => {
            return new Promise<void>((resolve) => {
                const fromNode = nodes[fromId];
                const toNode = nodes[toId];
                if (!fromNode || !toNode) return resolve();

                // Crear l√≠nea de movimiento usando el m√©todo seguro
                const trail = createMovementTrail(fromNode, toNode);

                const fromPos = center(fromNode);
                const toPos = center(toNode);
                const dx = toPos.x - fromPos.x;
                const dy = toPos.y - fromPos.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                setRunnerDirection(dx, dy);

                const duration = Math.max(400, (distance / speed) * 1000);
                const startTime = performance.now();

                runner.classList.add("moving");

                const animate = (currentTime: number) => {
                    const elapsed = currentTime - startTime;
                    const progress = Math.min(elapsed / duration, 1);

                    const eased =
                        progress < 0.5
                            ? 2 * progress * progress
                            : 1 - Math.pow(-2 * progress + 2, 3) / 2;

                    const currentX = fromPos.x + dx * eased;
                    const currentY = fromPos.y + dy * eased;

                    setRunnerPosition(currentX, currentY);

                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        runner.classList.remove("moving");
                        // Ocultar l√≠nea despu√©s del movimiento
                        setTimeout(() => {
                            if (trail && trail.parentNode) {
                                trail.classList.remove("active");
                                // Remover despu√©s de la animaci√≥n
                                setTimeout(() => {
                                    if (trail.parentNode) {
                                        trail.parentNode.removeChild(trail);
                                    }
                                }, 300);
                            }
                        }, 200);
                        resolve();
                    }
                };

                requestAnimationFrame(animate);
            });
        };

        const pressNode = async (nodeId: string) => {
            const node = nodes[nodeId];
            if (!node) return;

            node.classList.add("pressed");
            await new Promise((resolve) => setTimeout(resolve, 300));
            node.classList.remove("pressed");
        };

        // NUEVO: Sistema de conexiones din√°micas
        const connections = [
            { from: "node-trigger", to: "node-ai", type: "line" },
            { from: "node-ai", to: "node-action", type: "line" },
            { from: "node-action", to: "node-pipeline", type: "line" },
            { from: "node-action", to: "node-notify", type: "line" },
            { from: "node-pipeline", to: "node-email", type: "curve" },
            { from: "node-pipeline", to: "node-chat", type: "curve" },
            { from: "node-crm", to: "node-api", type: "line" },
            { from: "node-action", to: "node-whatsapp", type: "line" },
            { from: "node-action", to: "node-targeting", type: "curve" },
            { from: "node-whatsapp", to: "node-crm", type: "curve" },
            { from: "node-targeting", to: "node-forms", type: "curve" },
        ];

        // NUEVO: Funci√≥n para crear conexiones din√°micas
        const createDynamicConnections = () => {
            // Limpiar conexiones existentes
            dynamicSvg.innerHTML = "";

            const containerRect = getContainerRect();

            connections.forEach(({ from, to, type }) => {
                const fromNode = document.getElementById(from);
                const toNode = document.getElementById(to);

                if (!fromNode || !toNode) return;

                const fromRect = fromNode.getBoundingClientRect();
                const toRect = toNode.getBoundingClientRect();

                // Calcular posiciones relativas al contenedor automation-flows
                const flowsContainer =
                    document.querySelector(".automation-flows");
                const flowsRect = flowsContainer?.getBoundingClientRect();

                if (!flowsRect) return;

                const fromX =
                    ((fromRect.left - flowsRect.left + fromRect.width / 2) /
                        flowsRect.width) *
                    100;
                const fromY =
                    ((fromRect.top - flowsRect.top + fromRect.height / 2) /
                        flowsRect.height) *
                    100;
                const toX =
                    ((toRect.left - flowsRect.left + toRect.width / 2) /
                        flowsRect.width) *
                    100;
                const toY =
                    ((toRect.top - flowsRect.top + toRect.height / 2) /
                        flowsRect.height) *
                    100;

                // Crear el path SVG
                const path = document.createElementNS(
                    "http://www.w3.org/2000/svg",
                    "path",
                );

                if (type === "curve") {
                    // Mejorar c√°lculo de curva
                    const controlX = (fromX + toX) / 2;
                    const controlY =
                        fromY < toY
                            ? Math.min(fromY, toY) - 20
                            : Math.max(fromY, toY) + 20;

                    const pathData = `M ${fromX} ${fromY} Q ${controlX} ${controlY} ${toX} ${toY}`;
                    path.setAttribute("d", pathData);
                } else {
                    // L√≠nea recta
                    const pathData = `M ${fromX} ${fromY} L ${toX} ${toY}`;
                    path.setAttribute("d", pathData);
                }

                // Aplicar estilos mejorados
                path.setAttribute("class", "dynamic-connection-path");
                path.setAttribute("stroke", "var(--accent)");
                path.setAttribute("stroke-width", ".3");
                path.setAttribute("z-index", "-40");
                path.setAttribute("fill", "none");
                path.setAttribute("opacity", "0.2");
                path.setAttribute("stroke-linecap", "round");
                path.setAttribute("stroke-dasharray", "1 1");

                dynamicSvg.appendChild(path);
            });
        };

        // NUEVO: Actualizar conexiones din√°micas
        const updateDynamicConnections = () => {
            requestAnimationFrame(() => {
                createDynamicConnections();
            });
        };

        // CORREGIR: Loop principal simplificado
        const runFlowLoop = async () => {
            const firstNode = nodes[flow[0]];
            if (firstNode) {
                const pos = center(firstNode);
                setRunnerPosition(pos.x, pos.y);

                runner.style.opacity = "1";
                runner.style.visibility = "visible";

                // NUEVO: Crear conexiones din√°micas iniciales
                createDynamicConnections();

                await pressNode(flow[0]);
            }

            while (true) {
                for (let i = 0; i < flow.length - 1; i++) {
                    const fromId = flow[i];
                    const toId = flow[i + 1];

                    await moveRunner(fromId, toId);
                    await pressNode(toId);
                    await new Promise((resolve) => setTimeout(resolve, 300));
                }
            }
        };

        // Inicializar
        runFlowLoop();

        // NUEVO: Actualizar conexiones en resize
        let resizeTimeout: string | number | NodeJS.Timeout | undefined;
        window.addEventListener("resize", () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                const firstNode = nodes[flow[0]];
                if (firstNode) {
                    const pos = center(firstNode);
                    setRunnerPosition(pos.x, pos.y);
                }
                // Actualizar conexiones din√°micas
                updateDynamicConnections();
            }, 100);
        });

        // NUEVO: Observer para cambios en el layout
        const resizeObserver = new ResizeObserver(() => {
            updateDynamicConnections();
        });

        // Observar cambios en los nodos principales
        ["node-action", "node-email", "node-crm"].forEach((id) => {
            const element = document.getElementById(id);
            if (element) {
                resizeObserver.observe(element);
            }
        });
    });
</script>

<style>
    :root {
        --primary: #0066ff;
        --accent: #00b5e2;
        --success: #06ffa5;
    }

    /* Flujos de automatizaci√≥n */
    .automation-flows {
        position: absolute;
        top: 4em;
        right: 0;
        width: 50%;
        height: 80%;
        pointer-events: none;
        z-index: 5;
    }

    .flow-container {
        position: absolute;
        display: flex;
        align-items: center;
        gap: 2rem;
    }

    .main-flow {
        top: 50%;
        left: 5%;
        transform: translateY(-50%);
        flex-direction: row;
        gap: 3rem; /* Aumentar gap para mejor separaci√≥n */
    }

    .top-flow {
        top: 25%;
        left: 60%;
        transform: translateY(-50%);
        flex-direction: row;
        gap: 2rem;
    }

    .bottom-flow {
        top: 75%;
        left: 50%;
        transform: translateY(-50%);
        flex-direction: row;
        gap: 2rem;
    }

    /* NUEVO: SVG din√°mico para conexiones */
    .dynamic-connections-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 4;
        overflow: visible;
    }

    /* MEJORADO: Estilos para conexiones din√°micas con mejor sensaci√≥n de flujo */
    .dynamic-connection-path {
        stroke: var(--accent);
        stroke-width: 1.8;
        opacity: 0.7;
        stroke-linecap: round;
        stroke-dasharray: 15 8;
        fill: none;
        animation:
            dataFlow 3s linear infinite,
            pulseFlow 2s ease-in-out infinite alternate;

        filter: drop-shadow(0 0 6px rgba(0, 181, 226, 0.4));
        transition: all 0.4s ease;
    }

    @keyframes dataFlow {
        0% {
            stroke-dashoffset: 0;
        }
        100% {
            stroke-dashoffset: -46;
        }
    }

    @keyframes pulseFlow {
        0% {
            stroke-width: 1.8;
            opacity: 0.7;
            filter: drop-shadow(0 0 6px rgba(0, 181, 226, 0.4));
        }
        100% {
            stroke-width: 2.4;
            opacity: 1;
            filter: drop-shadow(0 0 12px rgba(0, 181, 226, 0.8));
        }
    }

    /* NUEVO: Efecto de part√≠culas en las l√≠neas */
    .dynamic-connection-path::before {
        content: "";
        position: absolute;
        width: 4px;
        height: 4px;
        background: var(--success);
        border-radius: 50%;
        animation:
            particleFlow 4s linear infinite,
            particleGlow 1.5s ease-in-out infinite alternate;
        box-shadow: 0 0 8px var(--success);
    }

    @keyframes particleFlow {
        0% {
            offset-distance: 0%;
            opacity: 0;
        }
        10% {
            opacity: 1;
        }
        90% {
            opacity: 1;
        }
        100% {
            offset-distance: 100%;
            opacity: 0;
        }
    }

    @keyframes particleGlow {
        0% {
            transform: scale(1);
            box-shadow: 0 0 8px var(--success);
        }
        100% {
            transform: scale(1.5);
            box-shadow: 0 0 16px var(--success);
        }
    }

    .connection-line {
        width: 100px;
        height: 4px;
        overflow: visible;
    }

    .connection-curve {
        width: 120px;
        height: 30px;
        overflow: visible;
    }

    .animated-line,
    .curved-line {
        stroke: var(--primary);
        stroke-width: 3;
        opacity: 0.6;
        stroke-linecap: round;
        stroke-dasharray: 8 4;
        animation:
            lineFlow 3s linear infinite,
            lineGlow 2s ease-in-out infinite alternate;
        filter: drop-shadow(0 0 8px rgba(0, 102, 255, 0.4));
        transition: all 0.3s ease;
    }

    /* Animaci√≥n principal del flujo de datos */
    @keyframes lineFlow {
        0% {
            stroke-dashoffset: 0;
        }
        100% {
            stroke-dashoffset: -24;
        }
    }

    /* Animaci√≥n de resplandor */
    @keyframes lineGlow {
        0% {
            stroke-width: 3;
            opacity: 0.6;
            filter: drop-shadow(0 0 8px rgba(0, 102, 255, 0.4));
        }
        100% {
            stroke-width: 4;
            opacity: 0.9;
            filter: drop-shadow(0 0 16px rgba(0, 102, 255, 0.8));
        }
    }

    /* Efecto hover en las l√≠neas */
    .connection-line:hover .animated-line,
    .connection-curve:hover .curved-line {
        stroke: var(--accent);
        stroke-width: 5;
        opacity: 1;
        animation-duration: 1.5s, 1s;
        filter: drop-shadow(0 0 20px rgba(0, 181, 226, 1));
    }

    /* Variaci√≥n para l√≠neas curvas */
    .curved-line {
        stroke-width: 2.5;
        animation:
            curveFlow 3.5s linear infinite,
            curveGlow 2.5s ease-in-out infinite alternate;
    }

    @keyframes curveFlow {
        0% {
            stroke-dashoffset: 0;
        }
        100% {
            stroke-dashoffset: -20;
        }
    }

    @keyframes curveGlow {
        0% {
            stroke-width: 2.5;
            opacity: 0.5;
        }
        100% {
            stroke-width: 3.5;
            opacity: 0.8;
        }
    }

    /* Efecto de pulso en intersecciones */
    .connection-line::before,
    .connection-curve::before {
        content: "";
        position: absolute;
        width: 6px;
        height: 6px;
        background: var(--success);
        border-radius: 50%;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        animation: pulse 2s ease-in-out infinite;
        box-shadow: 0 0 10px var(--success);
    }

    @keyframes pulse {
        0%,
        100% {
            transform: translate(-50%, -50%) scale(1);
            opacity: 1;
        }
        50% {
            transform: translate(-50%, -50%) scale(1.5);
            opacity: 0.7;
        }
    }

    /* L√≠nea de movimiento mejorada */
    .movement-trail {
        position: absolute;
        height: 4px;
        background: linear-gradient(
            90deg,
            transparent 0%,
            var(--accent) 20%,
            var(--primary) 50%,
            var(--accent) 80%,
            transparent 100%
        );
        border-radius: 3px;
        opacity: 0;
        z-index: 6;
        pointer-events: none;
        box-shadow:
            0 0 12px rgba(0, 181, 226, 0.8),
            0 0 20px rgba(0, 102, 255, 0.4);
        transition: opacity 0.3s ease;
    }

    .movement-trail.active {
        opacity: 1;
        animation:
            trailPulse 1.2s ease-in-out,
            trailMove 0.8s ease-out;
    }

    @keyframes trailPulse {
        0%,
        100% {
            transform: scaleY(1);
            box-shadow:
                0 0 12px rgba(0, 181, 226, 0.8),
                0 0 20px rgba(0, 102, 255, 0.4);
        }
        50% {
            transform: scaleY(2);
            box-shadow:
                0 0 20px rgba(0, 181, 226, 1),
                0 0 30px rgba(0, 102, 255, 0.6);
        }
    }

    @keyframes trailMove {
        0% {
            background: linear-gradient(
                90deg,
                var(--accent) 0%,
                transparent 20%,
                transparent 80%,
                transparent 100%
            );
        }
        50% {
            background: linear-gradient(
                90deg,
                transparent 0%,
                transparent 20%,
                var(--primary) 50%,
                transparent 80%,
                transparent 100%
            );
        }
        100% {
            background: linear-gradient(
                90deg,
                transparent 0%,
                transparent 20%,
                transparent 80%,
                var(--accent) 100%
            );
        }
    }

    /* Responsive mejorado con mejor flujo */
    @media (min-width: 1024px) {
        .automation-flows {
            width: 55%;
        }

        .main-flow {
            left: 2%;
            gap: 4rem;
        }

        .top-flow {
            left: 55%;
            top: 20%;
        }

        .bottom-flow {
            left: 45%;
            top: 80%;
        }

        /* Conexiones m√°s visibles en desktop */
        .dynamic-connection-path {
            stroke-width: 2.2;
            stroke-dasharray: 18 10;
        }
    }

    @media (max-width: 1024px) {
        .automation-flows {
            width: 60%;
        }

        .main-flow {
            left: 5%;
            gap: 2rem;
        }

        .dynamic-connection-path {
            stroke-width: 1.5;
            stroke-dasharray: 12 6;
            animation-duration: 4s, 2.5s;
        }
    }

    @media (max-width: 768px) {
        .automation-flows {
            width: 100%;
            opacity: 0.3;
        }

        .floating-node {
            display: none;
        }

        .main-flow {
            left: 2%;
            gap: 1rem;
        }

        .top-flow {
            left: 35%;
            top: 15%;
        }

        .bottom-flow {
            left: 25%;
            top: 85%;
        }

        /* Conexiones m√°s sutiles en m√≥vil */
        .dynamic-connection-path {
            stroke-width: 1.2;
            stroke-dasharray: 10 5;
            animation-duration: 5s, 3s;
            opacity: 0.5;
        }
    }

    /* Mejoras para accesibilidad */
    @media (prefers-reduced-motion: reduce) {
        .animated-line,
        .curved-line {
            animation: none;
        }

        .connection-line::before,
        .connection-curve::before {
            animation: none;
        }

        .movement-trail {
            animation: none;
        }
    }
</style>
